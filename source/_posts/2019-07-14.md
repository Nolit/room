---
title: CleanArchitecture読みました
---

### 始めに
先輩からお借りした[Clean Architecture](https://www.amazon.co.jp/Clean-Architecture-%E9%81%94%E4%BA%BA%E3%81%AB%E5%AD%A6%E3%81%B6%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E6%A7%8B%E9%80%A0%E3%81%A8%E8%A8%AD%E8%A8%88-Robert-C-Martin/dp/4048930656/)を読みました。
大体300ページぐらいの内容となっており、1時間あたり20ページぐらいのペースで読めたのでそんなに時間は掛からなかったですね。読むだけなら。。。
関そうとしては、これまではクラス単位で物事を考えていたのですが、さらに大きい単位(コンポーネント)で考えることを知りました。
依存関係を設計し、変更に強い独立して動くコンポーネントを作るのは楽しそうだなと。
重要なのはビジネスルールであり、DBや表示は最重要ではない、という主張はDDDと同じかなと思いました。
ここからは読みながらメモしたことをつらつらと残しておきます。

## 第一部 イントロダクション
いかにアーキテクチャが重要であるかが書かれていた気がします。
ただ私の経験として、こういった本の序章が役に立ったことがなかったのでほとんど斜め読みでした。

## 第二部 プログラミングパラダイム
ここではプログラミングパラダイムについて取り上げられました。
構造化プログラミングの章を私が読んだ理解としては、

```
これまでの無制限のgotoを廃止し、分岐・反復で制御を行うことによりモジュールを機能的に分割可能とする。
```

ということかなと思いました。
確かに無制限のgotoがあるとモジュールは信用できないよなーと。
呼び出したらどこに飛んでいくかわからないですから。
オブジェクト指向プログラミング(以下OOP)では、OOPとは何か？に対するいくつかの説明をまず否定した上で、カプセル化・継承・ポリモーフィズムについて順番にOOPの特徴といえるかを検証しました。
結論として、上記三つはC言語でも可能でした。
カプセル化についてはヘッダと実装が分かれるC言語の方がより強固とのことです。
ただ、継承はクラスのメンバの順番が同じ時に行い、ポリモーフィズムは関数ポインタで行うので、安全性や便利さはOOPの特徴と言えそうです。
関数型言語では、不変性について取り上げられていましたが、正直よく分かりませんでした。

### イベントソーシング
不変性を維持するための取り組みです。
取引によって状態を変更するのではなく、取引自体（トランザクション）を記録することによって、不変性を維持します。

## 第三部 設計の原則
ここでは設計の原則について触れました。
取り敢えず理解はできたのですが、こういうのは実際にやってみないと分からないなーという感じです。

### 単一責任の原則
責務は一つだー！変更理由は一つだー！程度の理解が具体化されて良かったです。
正しくは、「利用者のグループをアクターとし、モジュールは一つのアクターに対して責任を持つべき」という原則でした。
例も分かりやすく、モジュールが二つのアクターに対して責任を持ってしまった為に起こる問題が分かりました。
DDDの境界付けられたコンテキストにも同じような性質がある気がします。

### オープンクローズドの原則
こちらもなんとなくが具体化されてよかったです。
「ソフトウェアをコンポーネントに分割し、DIP(後述)を利用して変更の多いコンポーネントを上位の階層に持ってくる」と理解しました。

### リスコフの置換原則
もともとは継承の使い方の指針でしたが、インターフェースと実装の指針としても適用できます。
また、自分は知らなかったのですが、有名な「正方形・長方形問題」というものがあるそうです。
「正方形は長方形の派生型か？」という問題で、答えはNOでした。
長方形は縦・横のそれぞれ別に変更できますが、正方形は出来ず交換可能ではないからですね。

### インターフェース分離の原則
具象全てに依存させるのではなく、インターフェースを実装することにより、最小限の依存で済むようにしましょうね・・・ぐらいに理解しました。
ただ正直、インターフェースをこの目的で使うことが今までになかったですね・・・。

### 依存関係逆転の原則
DDDでも出てくる原則ですね。
コンポーネント間の依存方向を逆にすることができます。
ビューの表示を例にすると、通常であれば「コントローラ->ビュー」となりコントローラがビューに依存するはずです。
ただこれだと、変更の多いビューにコントローラが影響を受けます。
そこで、コントローラ内にインターフェースを作成しコントローラはそのインターフェースに依存させます。ビューはそのインターフェースを実装するようにします。
そうすることによりコンポーネントレベルで見ると、コントローラ<-ビューという依存関係になり、コントローラがビューの影響を受けません。

## 第四部 コンポーネントの原則
ここではコンポーネントについて説明がありました。
本書の序盤から何度か出てきている単語で、クラスの論理的なグループぐらいに思っていましたが、「デプロイ可能な単位」と定義しているようです。
ここで伝えたかったことは、

* クラスを変更理由によって適切なコンポーネントに分離する
* 循環依存はさぜず常に一方向への依存とする
* より安定しているコンポーネントに依存させる。

ということかと思いました。
その為の方法として、

* インターフェース分離の原則や単一責任の原則を、コンポーネントに適用したパターン
* 安定度の指標を計算する方法

といったことも書いてありました。

## 第五部 アーキテクチャ
ここではアーキテクチャの目的として

**システムの開発・デプロイ・運用を容易にする**

ことを挙げており、コンポーネントを正しく設計することで以下のように実現できると主張しています。


**開発**
開発中にチーム間で競合しないようにコンポーネント単位で作業を分ける

**デプロイ**
コンポーネントの依存関係を管理することにより、分割したデプロイが可能となる

**運用**
コンポーネント間の通信方法を特定の技術(関数呼び出し・プロセス間通信・HTTP等)に依存させないことで、必要に応じて変更することができる

### 詳細の選択肢を残しておく
本書で何度も出てくる言葉です。
詳細とは、

* DB
* View
* Framework
* コンポーネント間の通信

といった感じで、コンポーネントとして切り出し、システムにプラグインできるような構成が望ましいです。
それによって、上記の技術の決定を先延ばしにできます。

### クリーンアーキテクチャ
ここではあの有名な丸い図が出てきました。
理解できたのかかなり怪しいのですが、一方向の依存・安定したコンポーネントへの依存といった原則が守られています。
本書のここまでの説明は、この図を理解するためのものだったのかなぁという気がします。
ビジネスルールとユースケースの分離についてはDDDでも出てきた話ですね。

## 第六部 詳細
ここではDB・Web・フレームワークは詳細であることが再度強調されています。
一番重要なのはビジネスルールであり、表示形式や保存方法は重要ではないという主張ですね。
いくつかの具体例から、上記がいかに変わりやすいものであるか書かれてありました。