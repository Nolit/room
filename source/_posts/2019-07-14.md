---
title: CleanArchitecture読了
---

### 始めに
先輩からお借りした[Clean Architecture](https://www.amazon.co.jp/Clean-Architecture-%E9%81%94%E4%BA%BA%E3%81%AB%E5%AD%A6%E3%81%B6%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E6%A7%8B%E9%80%A0%E3%81%A8%E8%A8%AD%E8%A8%88-Robert-C-Martin/dp/4048930656/)を読みました。
読みながら印象に残ったことをつらつらと書いていきます。

## 第一部
いかにArchitectureが重要であるかが書かれていた気がします。
ただ私の経験として、こういった本の序章が役に立ったことがなかったのでほとんど斜め読みでした。
ごめんなさい。

## 第二部
ここではプログラミングパラダイムについて取り上げられました。
構造化プログラミングの章を私が読んだ理解としては、

```
これまでの無制限のgotoを廃止し、分岐・反復で制御を行うことによりモジュールを機能的に分割可能とする。
```

ということかなと思いました。
確かに無制限のgotoがあるとモジュールは信用できないよなーと。
呼び出したらどこに飛んでいくかわからないですから。
オブジェクト指向プログラミング(以下OOP)では、OOPとは何か？に対するいくつかの説明をまず否定した上で、カプセル化・継承・ポリモーフィズムについて順番にOOPの特徴といえるかを検証しました。
結論として、上記三つはC言語でも可能でした。
カプセル化についてはヘッダと実装が分かれるC言語の方がより強固とのことです。
ただ、継承はクラスのメンバの順番が同じ時に行い、ポリモーフィズムは関数ポインタで行うので、安全性や便利さはOOPの特徴と言えそうです。
関数型言語では、不変性について取り上げられていましたが、正直よく分かりませんでした。

### イベントソーシング
不変性を維持するための取り組みです。
取引によって状態を変更するのではなく、取引自体（トランザクション）を記録することによって、不変性を維持します。

## 第三部
ここでは設計の原則について触れました。
取り敢えず理解はできたのですが、こういうのは実際にやってみないと分からないなーという感じです。

### 単一責任の原則
責務は一つだー！変更理由は一つだー！程度の理解が具体化されて良かったです。
正しくは、「利用者のグループをアクターとし、モジュールは一つのアクターに対して責任を持つべき」という原則でした。
例も分かりやすく、モジュールが二つのアクターに対して責任を持ってしまった為に起こる問題が分かりました。
DDDの境界付けられたコンテキストにも同じような性質がある気がします。

### オープンクローズドの原則
こちらもなんとなくが具体化されてよかったです。
「ソフトウェアをコンポーネントに分割し、DIP(後述)を利用して変更の多いコンポーネントを上位の階層に持ってくる」と理解しました。

### リスコフの置換原則
もともとは継承の使い方の指針でしたが、インターフェースと実装の指針としても適用できます。
また、自分は知らなかったのですが、有名な「正方形・長方形問題」というものがあるそうです。
「正方形は長方形の派生型か？」という問題で、答えはNOでした。
長方形は縦・横のそれぞれ別に変更できますが、正方形は出来ず交換可能ではないからですね。

### インターフェース分離の原則
具象全てに依存させるのではなく、インターフェースを実装することにより、最小限の依存で済むようにしましょうね・・・ぐらいに理解しました。
ただ正直、インターフェースをこの目的で使うことが今までになかったですね・・・。

### 依存関係逆転の原則
DDDでも出てくる原則ですね。
コンポーネント間の依存方向を逆にすることができます。
ビューの表示を例にすると、通常であれば「コントローラ->ビュー」となりコントローラがビューに依存するはずです。
ただこれだと、変更の多いビューにコントローラが影響を受けます。
そこで、コントローラ内にインターフェースを作成しコントローラはそのインターフェースに依存させます。ビューはそのインターフェースを実装するようにします。
そうすることによりコンポーネントレベルで見ると、コントローラ<-ビューという依存関係になり、コントローラがビューの影響を受けません。

## 第四部
ここではコンポーネントについて説明がありました。
本書の序盤から何度か出てきている単語で、モジュールの論理的なグループぐらいに思っていましたが、「デプロイ可能な単位」と定義しているようです。
